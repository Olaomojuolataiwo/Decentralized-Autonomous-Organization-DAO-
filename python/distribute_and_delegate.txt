#!/usr/bin/env python3
"""
distribute_and_delegate.py

Mint 100,000,000 FMBR total supply,
distribute 300,000 FMBR to each member in dao_members.json,
self-delegate for each member,
mint remainder to owner.

Produces: mint_report.json
"""

import os
import json
import time
from decimal import Decimal
from pathlib import Path
from dotenv import load_dotenv
from web3 import Web3
from eth_account import Account

load_dotenv()

RPC_URL = os.getenv("RPC_URL")
PRIVATE_KEY = os.getenv("PRIVATE_KEY")  # owner / deployer private key
TOKEN_ADDRESS = Web3.to_checksum_address(os.getenv("TOKEN_ADDRESS"))
MEMBERS_FILE = os.getenv("MEMBERS_FILE", "./dao_members.json")
CHAIN_ID = int(os.getenv("CHAIN_ID", "11155111"))  # Sepolia chain id default

if not RPC_URL or not PRIVATE_KEY or not TOKEN_ADDRESS:
    raise SystemExit("RPC_URL, PRIVATE_KEY and TOKEN_ADDRESS environment variables must be set.")

w3 = Web3(Web3.HTTPProvider(RPC_URL))
owner_acct = Account.from_key(PRIVATE_KEY)
owner_addr = owner_acct.address

print(f"RPC: {RPC_URL}")
print(f"Owner: {owner_addr}")
print(f"Token: {TOKEN_ADDRESS}")
print(f"Members file: {MEMBERS_FILE}")

# Minimal ABI: mint(address,uint256) and delegate(address)
TOKEN_ABI = [
    {
        "inputs": [
            {"internalType": "address", "name": "to", "type": "address"},
            {"internalType": "uint256", "name": "amount", "type": "uint256"},
        ],
        "name": "mint",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "inputs": [{"internalType": "address", "name": "delegatee", "type": "address"}],
        "name": "delegate",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "inputs": [],
        "name": "decimals",
        "outputs": [{"internalType": "uint8", "name": "", "type": "uint8"}],
        "stateMutability": "view",
        "type": "function",
    },
]

token = w3.eth.contract(address=TOKEN_ADDRESS, abi=TOKEN_ABI)

# load members
members_path = Path(MEMBERS_FILE)
if not members_path.exists():
    raise SystemExit(f"{MEMBERS_FILE} not found")

with open(members_path, "r") as f:
    members = json.load(f)

if not isinstance(members, list):
    raise SystemExit("Members file must be a JSON array of objects with 'address' and 'private_key'.")

num_members = len(members)
print(f"Loaded {num_members} members")

# Constants
DECIMALS = token.functions.decimals().call()
MULT = 10 ** DECIMALS

# Requested distribution
PER_MEMBER_TOKENS = Decimal("300000")  # 300k each
TOTAL_SUPPLY_DESIRED = Decimal("100000000")  # 100M

per_member_amount = int(PER_MEMBER_TOKENS * MULT)
total_distributed = per_member_amount * num_members
total_supply_units = int(TOTAL_SUPPLY_DESIRED * MULT)
remainder_for_owner = total_supply_units - total_distributed

if remainder_for_owner < 0:
    raise SystemExit("Per-member allocation * members exceeds total supply. Adjust numbers.")

print(f"Per member amount (raw): {per_member_amount}")
print(f"Total distributed (raw): {total_distributed}")
print(f"Total supply (raw): {total_supply_units}")
print(f"Remainder (owner) (raw): {remainder_for_owner}")

# Report structure
report = {
    "timestamp": int(time.time()),
    "chain_id": CHAIN_ID,
    "rpc": RPC_URL,
    "token": TOKEN_ADDRESS,
    "owner": owner_addr,
    "num_members": num_members,
    "per_member_amount": str(per_member_amount),
    "total_distributed": str(total_distributed),
    "remainder_for_owner": str(remainder_for_owner),
    "mint_txs": [],
}

# Nonce management (owner signs all transactions)
nonce = w3.eth.get_transaction_count(owner_addr)
gas_price = w3.eth.gas_price
print(f"Starting nonce: {nonce}, gas_price: {gas_price}")

def send_tx(tx):
    signed = Account.sign_transaction(tx, PRIVATE_KEY)
    tx_hash = w3.eth.send_raw_transaction(signed.raw_transaction)
    print(f"Sent tx {tx_hash.hex()} waiting for receipt...")
    receipt = w3.eth.wait_for_transaction_receipt(tx_hash, timeout=600)
    return receipt

# 1) Mint to members (sequential)
for idx, m in enumerate(members):
    member_addr = Web3.to_checksum_address(m["address"])
    print(f"[{idx+1}/{num_members}] Mint -> {member_addr}")

    tx = token.functions.mint(member_addr, per_member_amount).build_transaction({
        "chainId": CHAIN_ID,
        "gas": 500_000,  # gas limit guess - mint is cheap; adjust if needed
        "gasPrice": gas_price,
        "nonce": nonce,
        "from": owner_addr,
    })

    receipt = send_tx(tx)
    nonce += 1

    # delegate (self-delegate)
    print(f"       Delegating to {member_addr}")
    tx2 = token.functions.delegate(member_addr).build_transaction({
        "chainId": CHAIN_ID,
        "gas": 200_000,
        "gasPrice": gas_price,
        "nonce": nonce,
        "from": owner_addr,
    })
    receipt2 = send_tx(tx2)
    nonce += 1

    report["mint_txs"].append({
        "member": member_addr,
        "mint_tx": receipt.transactionHash.hex(),
        "mint_gasUsed": receipt.gasUsed,
        "mint_blockNumber": receipt.blockNumber,
        "delegate_tx": receipt2.transactionHash.hex(),
        "delegate_gasUsed": receipt2.gasUsed,
        "delegate_blockNumber": receipt2.blockNumber,
    })

    # small pause to avoid node throttling
    time.sleep(0.15)

# 2) Mint remainder to owner
if remainder_for_owner > 0:
    print("Minting remainder to owner:", owner_addr)
    tx = token.functions.mint(owner_addr, remainder_for_owner).build_transaction({
        "chainId": CHAIN_ID,
        "gas": 500_000,
        "gasPrice": gas_price,
        "nonce": nonce,
        "from": owner_addr,
    })
    receipt = send_tx(tx)
    report["owner_mint"] = {
        "mint_tx": receipt.transactionHash.hex(),
        "mint_gasUsed": receipt.gasUsed,
        "mint_blockNumber": receipt.blockNumber,
    }
    nonce += 1

# finalize
out_path = Path("mint_report.json")
with open(out_path, "w") as f:
    json.dump(report, f, indent=2)

print(f"Done. Report written to {out_path}")
